{
  
    
        "post0": {
            "title": "Dataclasses For The Masses",
            "content": "DaaS Made Easy . Many data analysts, data engineers, and data scientists (trying to be inclusive here) build tables for a living. The product of their work is data. The desired features of the data product vary from customer to customer. A finance executive prefers a bunch of spreadsheets. An operations team likes their dashboards. For consumption within the data team, you open up dataframes-as-a-service shop. If you are pursuing enterprise-grade solutions, there&#39;s a high chance they will be centered around OLAP databases. . I would like to share a Python tool that helps me design, document, and deploy my tables. The goal was to make the data class declaration as concise as it gets, so that one can prototype rapidly and arrive at the optimal data model. . class SweetTable: a: datatype1 b: datatype2 . You might notice parallels to ORM solutions like SQLAlchemy and Django. . Django Model is the single, definitive source of information about your data. It contains the essential fields and behaviors of the data you’re storing. Generally, each model maps to a single database table. . from django.db import models class Musician(models.Model):first_name = models.CharField(max_length=50) last_name = models.CharField(max_length=50) instrument = models.CharField(max_length=100) class Album(models.Model): artist = models.ForeignKey(Musician, on_delete=models.CASCADE) name = models.CharField(max_length=100) release_date = models.DateField() num_stars = models.IntegerField() . The main issue with existing Python ORMs is that they are made for transactional tasks, where row-by-row data manipulation is common and data relationships are important. I want none of that. What do I want? I want what The Most Interesting Data Engineer In The World (TMIDEITW) wants. . What does TMIDEITW want? . Her Parquet files smell of rich mahogany. | Her data types are enforced on every continent. Even the NULLs. | She does not often add data. But when she does, she adds a billion rows. | . In less interesting but more clear terms, we want to construct dataclasses for a future columnar database: . efficient, typed, nullable data structures | interfaces with pandas for familiar analytical tasks | on-demand conversion to pyarrow objects, en route to Parquet files | . Why not pandas or arrow or...? . I strongly feel that Arrow is a key technology for the next generation of data science tools. I laid out my vision for this recently in my 2017 JupyterCon keynote. &ndash;Wes McKinney (creator of Pandas) . Pandas rules. It&#39;s like a Swiss-army knife - you have all kinds of tools but they&#39;re not optimal for the tasks. The price you pay: it&#39;s slow. Pandas defaults to the most accommodating data types: object, np.float64, np.int64. Can some of your fields be casted to something more efficient? My loose definition of a boundary between small data and big data is the amount of RAM of your laptop. Optimizing your data structures, starting with data types, can make &quot;big&quot; data &quot;small&quot; again. . Arrow is harder to say no to. It&#39;s efficient, typed, and nullable. There are neat pandas-like functions not offered by the more math-heavy numpy. The library is large, but it&#39;s already required for writing parquet files. Probably the main reason for not choosing Pyarrow is the desire to meet the data pros where they are, and today this means numpy. But don&#39;t worry: both pd.DataFrame and pyarrow table will be at your fingertips. We do not consider Python&#39;s native typed arrays - not to be confused with lists! The fact that one needs to be reminded that they&#39;re not the same speaks a lot to how often they are used. . Implementation . Read through the story or skip get to the point. . Minimal Example . Let&#39;s start with a very simple class with two short numpy arrays as predefined attributes. We&#39;ll also define a function that performs a simple analytical task, a row-wise sum. I spell out Two in the class name to remind me that we have two data elements. . import numpy as np class SimpleDataclassTwo: a = np.array([-123, 1, 99]) b = np.array([1234, 0, -9876]) def row_sum(self): return self.a + self.b simpledata2 = SimpleDataclassTwo() simpledata2.row_sum() . array([ 1111, 1, -9777]) . simpledata2 . &lt;__main__.SimpleDataclassTwo at 0x7fda41f5ef70&gt; . that was not very helpful... but at least we can access the attributes: . simpledata2.a . array([-123, 1, 99]) . simpledata2.b . array([ 1234, 0, -9876]) . try to make another instance? . try: SimpleDataclassTwo(np.array([1,2]), np.array([41, 40])) except TypeError: print(&quot;failed, because we don&#39;t have __init__&quot;) . failed, because we don&#39;t have __init__ . ...and that&#39;s about it. Before we start writing __init__ and __repr__, let me introduce you to your new best friend: attrs . Attrs . attrs is the Python package that will bring back the joy of writing classes. Trusted by NASA for Mars missions since 2020! . &ndash; https://www.attrs.org/en/stable/index.html NB: if you&#39;ve previously used attrs, they recently switched from @attr.s(auto_attrib=True) to @attrs.define. . import attr import attrs . @attrs.define(slots=False) class AttrsDataclassTwo: a: np.array = np.array([-123, 1, 99]) b: np.array = np.array([1234, 0, -9876]) def row_sum(self): return self.a + self.b attrs_data2 = AttrsDataclassTwo(np.array([1,2]), np.array([41, 40])) attrs_data2 . AttrsDataclassTwo(a=array([1, 2]), b=array([41, 40])) . With one decorator, two problems with the original SimpleDataclassTwo are solved before you knew they were problems. Let&#39;s learn more about this class instance. For this purpose, I often reach for __dict__: . attrs_data2.__dict__ . {&#39;a&#39;: array([1, 2]), &#39;b&#39;: array([41, 40])} . this reminds me of...how you instantiate a Pandas dataframe! . Enable Pandas and Pyarrow . import pandas as pd import pyarrow as pa . pd.DataFrame(attrs_data2.__dict__) . a b . 0 1 | 41 | . 1 2 | 40 | . @attrs.define(slots=False) class AttrsPandasArrowDataclassTwo: a: np.array = np.array([-123, 1, 99]) b: np.array = np.array([1234, 0, -9876]) @property def df(self): return pd.DataFrame(self.__dict__) @property def pa(self): return pa.table(self.__dict__) data = AttrsPandasArrowDataclassTwo() . data.df . a b . 0 -123 | 1234 | . 1 1 | 0 | . 2 99 | -9876 | . data.pa . pyarrow.Table a: int64 b: int64 - a: [[-123,1,99]] b: [[1234,0,-9876]] . Nullable arrays . Type Enforcement . Inheritance . In The End . import numpy as np import pandas as pd import pyarrow as pa class ACHTUNG(Exception): pass @attrs.define(slots=False) class BaseColumnarModel: data_dict = {} def __attrs_post_init__(self): fields = list(self.__dict__) for field in fields: v = self.__dict__[field] _expected_dtype = self.__annotations__[field] if hasattr(v, &#39;_data&#39;): _dtype = v._data.dtype # for pandas ExtensionDtypes elif hasattr(v, &#39;dtype&#39;): _dtype = v.dtype # for numpy arrays else: _dtype = type(v) # for scalars x = np.empty(0, dtype=_expected_dtype).dtype y = np.empty(0, dtype=_dtype).dtype if x != y: raise ACHTUNG(f&#39;wrong dtype in `{field}`: `{_expected_dtype}` is not `{_dtype}`&#39;) return def __len__(self): return max(np.array(v).size for v in self.__dict__.values()) @classmethod def empty(cls): empty_fields = {} for k, v in cls.__annotations__.items(): empty_fields[k] = np.empty(0, dtype=v) return cls(**empty_fields) @property def df(self): return pd.DataFrame(self.__dict__) @property def pa(self): _length = self.__len__() arrow_dict = {} for k, v in self.__dict__.items(): if pd.api.types.is_scalar(v): arrow_dict[k] = pa.array(np.full(_length, v, dtype=type(v))) else: arrow_dict[k] = pa.array(v) return pa.table(arrow_dict, metadata=self.data_dict) @attrs.define(slots=False) class CoolDataFour(BaseColumnarModel): &quot;&quot;&quot;Example Dataclass.&quot;&quot;&quot; a: np.int8 b: np.bool_ c: str d: float data_dict = { &#39;a&#39;: &#39;integer field&#39;, &#39;b&#39;: &#39;is it important?&#39;, &#39;c&#39;: &#39;text&#39;, &#39;d&#39;: &#39;price to pay&#39;, } . CoolDataFour.empty().df # for building database templates . a b c d . all_scalars = CoolDataFour(a=np.int8(42), b=np.bool_(True), c=&#39;abc&#39;, d=1.2) all_scalars.pa . pyarrow.Table a: int8 b: bool c: string d: double - a: [[42]] b: [[true]] c: [[&#34;a&#34;]] d: [[1.2]] . somenulls = CoolDataFour(a=pd.array([99,None], dtype=pd.Int8Dtype()), b=np.bool_([0,1]), c=&#39;abc&#39;, d=1/2) somenulls.pa . pyarrow.Table a: int8 b: bool c: string d: double - a: [[99,null]] b: [[false,true]] c: [[&#34;a&#34;,&#34;a&#34;]] d: [[0.5,0.5]] . somenulls.pa.schema . a: int8 b: bool c: string d: double -- schema metadata -- a: &#39;integer field&#39; b: &#39;is it important?&#39; c: &#39;text&#39; d: &#39;price to pay&#39; . Now What? . Share your feedback in the comments! .",
            "url": "https://liquidcarbon.github.io/blog/attrs/dataclasses/numpy/pandas/olap/2022/09/13/Dataclasses-For-The-Masses.html",
            "relUrl": "/attrs/dataclasses/numpy/pandas/olap/2022/09/13/Dataclasses-For-The-Masses.html",
            "date": " • Sep 13, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "When Papa Atom Met Mama Atom",
            "content": "Bokeh . Let&#39;s use this example from Bokeh documentation to display an interactive Periodic Table of Elements. . A standard Bokeh workflow for displaying plots inline in Jupyter Notebook or Jupyter Lab goes like this: . 1) call output_notebook(), 2) construct our plot object p, 3) pass the plot object into show(). . The plots show up in the notebook but do not survive the process of conversion to a static HTML page. What do we do? . Using bokeh.embed.components, we can extract the JS and HTML snippets. Then we recombine them into one JS+HTML chunk with f-string formatting, and render the plot with the help of IPython.display. . from bokeh.plotting import figure, show, output_notebook from bokeh.sampledata.periodic_table import elements from bokeh.transform import dodge, factor_cmap . periods = [&quot;I&quot;, &quot;II&quot;, &quot;III&quot;, &quot;IV&quot;, &quot;V&quot;, &quot;VI&quot;, &quot;VII&quot;] groups = [str(x) for x in range(1, 19)] df = elements.copy() df[&quot;atomic mass&quot;] = df[&quot;atomic mass&quot;].astype(str) df[&quot;group&quot;] = df[&quot;group&quot;].astype(str) df[&quot;period&quot;] = [periods[x-1] for x in df.period] df = df[df.group != &quot;-&quot;] df = df[df.symbol != &quot;Lr&quot;] df = df[df.symbol != &quot;Lu&quot;] cmap = { &quot;alkali metal&quot; : &quot;#a6cee3&quot;, &quot;alkaline earth metal&quot; : &quot;#1f78b4&quot;, &quot;metal&quot; : &quot;#d93b43&quot;, &quot;halogen&quot; : &quot;#999d9a&quot;, &quot;metalloid&quot; : &quot;#e08d49&quot;, &quot;noble gas&quot; : &quot;#eaeaea&quot;, &quot;nonmetal&quot; : &quot;#f1d4Af&quot;, &quot;transition metal&quot; : &quot;#599d7A&quot;, } TOOLTIPS = [ (&quot;Name&quot;, &quot;@name&quot;), (&quot;Atomic number&quot;, &quot;@{atomic number}&quot;), (&quot;Atomic mass&quot;, &quot;@{atomic mass} Da&quot;), (&quot;CPK color&quot;, &quot;$color[hex, swatch]:CPK&quot;), (&quot;Melting point&quot;, &quot;@{melting point} K&quot;), (&quot;Boiling point&quot;, &quot;@{boiling point} K&quot;), (&quot;Density&quot;, &quot;@{density} g/mL&quot;), (&quot;Ionic radius&quot;, &quot;@{ion radius} pm&quot;), (&quot;Electronegativity&quot;, &quot;@{electronegativity}&quot;), (&quot;Year Discovered&quot;, &quot;@{year discovered}&quot;), ] p = figure(title=&quot;Periodic Table (omitting LA and AC Series)&quot;, width=1000, height=450, x_range=groups, y_range=list(reversed(periods)), tools=&quot;hover&quot;, toolbar_location=None, tooltips=TOOLTIPS) r = p.rect(&quot;group&quot;, &quot;period&quot;, 0.95, 0.95, source=df, fill_alpha=0.6, legend_field=&quot;metal&quot;, color=factor_cmap(&#39;metal&#39;, palette=list(cmap.values()), factors=list(cmap.keys()))) text_props = dict(source=df, text_align=&quot;left&quot;, text_baseline=&quot;middle&quot;) x = dodge(&quot;group&quot;, -0.4, range=p.x_range) p.text(x=x, y=&quot;period&quot;, text=&quot;symbol&quot;, text_font_style=&quot;bold&quot;, **text_props) p.text(x=x, y=dodge(&quot;period&quot;, 0.3, range=p.y_range), text=&quot;atomic number&quot;, text_font_size=&quot;11px&quot;, **text_props) p.text(x=x, y=dodge(&quot;period&quot;, -0.35, range=p.y_range), text=&quot;name&quot;, text_font_size=&quot;7px&quot;, **text_props) p.text(x=x, y=dodge(&quot;period&quot;, -0.2, range=p.y_range), text=&quot;atomic mass&quot;, text_font_size=&quot;7px&quot;, **text_props) p.text(x=[&quot;3&quot;, &quot;3&quot;], y=[&quot;VI&quot;, &quot;VII&quot;], text=[&quot;LA&quot;, &quot;AC&quot;], text_align=&quot;center&quot;, text_baseline=&quot;middle&quot;) p.outline_line_color = None p.grid.grid_line_color = None p.axis.axis_line_color = None p.axis.major_tick_line_color = None p.axis.major_label_standoff = 0 p.legend.orientation = &quot;horizontal&quot; p.legend.location =&quot;top_center&quot; p.hover.renderers = [r] # only hover element boxes . . # output_notebook() # works in a notebook but not on a Github Pages Jekyll site # show(p) # so we will use `components` instead . from bokeh.embed import components from IPython.display import display, HTML script, div = components(p) html = f&quot;&quot;&quot; &lt;script src=&quot;https://cdn.bokeh.org/bokeh/release/bokeh-2.4.3.min.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bokeh.org/bokeh/release/bokeh-widgets-2.4.3.min.js&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; {script} {div} &quot;&quot;&quot; . . Why triple quotes? . The f&quot;&quot;&quot; &quot;&quot;&quot; is an f-string literal.1 They are great for programmatically constructing large chunks of non-Python code. . 1. PEP 498 &ndash; Literal String Interpolation↩ . Success! . display(HTML(html)) . . Tip: Hover over the elements to see additional information. . Altair . Just works. (though the browser console is complaining) . import altair as alt . keep_columns = [&#39;group&#39;, &#39;electronegativity&#39;, &#39;atomic number&#39;, &#39;atomic mass&#39;, &#39;symbol&#39;] elements_ = elements.loc[elements.group != &#39;-&#39;, keep_columns].copy() elements_[&#39;group&#39;] = elements_[&#39;group&#39;].astype(int) . slider = alt.binding_range(min=1, max=18, step=1, name=&#39;group:&#39;) selector = alt.selection_single(fields=[&#39;group&#39;], bind=slider, init={&#39;group&#39;: 17}) chart = ( alt.Chart(elements_, title=f&quot;Periodic electronegativity trends within groups&quot;).mark_point() .encode( x=alt.X(&#39;electronegativity:Q&#39;, scale=alt.Scale(domain=(0.5, 4.5))), y=alt.Y(&#39;symbol:N&#39;, sort=elements.symbol.to_numpy()), tooltip=[&#39;symbol&#39;,&#39;atomic number&#39;,&#39;atomic mass&#39;] ) .add_selection(selector) .transform_filter(selector) .properties(width=400, height=200) .interactive() ) chart .",
            "url": "https://liquidcarbon.github.io/blog/altair/bokeh/elements/2022/09/12/Test-Bokeh-Altair.html",
            "relUrl": "/altair/bokeh/elements/2022/09/12/Test-Bokeh-Altair.html",
            "date": " • Sep 12, 2022"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://liquidcarbon.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://liquidcarbon.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}